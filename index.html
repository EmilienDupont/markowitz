<!DOCTYPE html>
<meta charset="utf-8">
<script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>

<style>
.axis path,
.axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
}

.axis text {
        font-family: sans-serif;
        font-size: 11px;
}

.line {
 fill: none;
 stroke: steelblue;
 stroke-width: 1.5px;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#datamatrix">Estimating Risk and Return</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Markowitz Portfolio Optimization</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here

      <p>
      We consider the classical portfolio problem introduced by Markowitz in 1952.
      For a set of stocks held over a peridod of time, we wish to maximise the expected return while minimising
      the risk.
      </p>

      <p>
      Also add section about Efficient Frontier
      </p>

      <p>
      Talk about Finance API and how model can be tested using real data
      </p>
    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>Model description goes here.</p>

      <p>
      We consider $n$ stocks held over a period of time (Add reference to Boyd). We denote by $x_i$ the fraction
      of the total wealth invested in stock $i$, i.e. $\sum_{i=1}^{n} x_i = 1$. In this way, a long position corresponds
      to $x_i > 0$ and a short position to $x_i < 0$. If we assume we cannot go short by a larger amount than $s_i$, we have the constraint
      \[
        x_i \geq s_i
      \]
      for each stock $i$.
      </p>

      <p>
      We denote by $r_i$ expected return of stock $i$ over the time period. The total return of the portfolio is then given by
      \[
        \text{return} = r^T x
      \]
      Since we have normalised the $x$ variables, this corresponds to a fractional return. For example, if $\text{return} = 0.12$
      this corresponds to 12% increase in the total value of the portfolio.
      </p>

      <p> To estimate the risk we use the variance, which is defined as
      \[
        \text{variance} = x^T \Sigma x
      \]
      where $\Sigma$ is the covariance matrix of the return. We wish to bound the risk, so we can introduce a parameter $\sigma_{max}$
      which will correspond to the maximum standard deviation (risk) allowed. This imposes a constraint
      \[
        x^T \Sigma x \leq \sigma_{max}^2
      \]
      </p>

      <p> So finally our model becomes
       \[
      \begin{array}{ll}
      \text{maximize} & r^T x \\
      \text{subject to} & \sum_{i=1}^{n} x_i = 1 \\
                        & x_i \geq 0 \quad \text{for} \, i=1,..,n \\
                        & x^T \Sigma x \leq \sigma_{max}^2
      \end{array}
      \]
      By solving the optimization problem for various values of the parameter $\sigma_{max}$ we can compute the efficient frontier for the problem.
      </p>

      </div>
      <div class="section" id="datamatrix">
      <h2><a href="#datamatrix" name="datamatrix">Estimating Risk and Return</a></h2>
      <p>
      There are several ways of computing the expected return and the variance. For this implementation, we use data collected from Yahoo Finance API
      giving the closing price of various stocks for the past $N$ days. We can then use this data to estimate the return and variance.
      </p>

      <p>
      For $n$ stocks and $N$ daily closing prices we define an $N \times n$ data matrix $D$, so that each
      column holds all the information for a single stock. So for each stock $j$ we define
       \[
      D_{ij} = \frac{ \text{closing price of $jth$ stock on $(i+1)th$ day}}{ \text{closing price of $jth$ stock on $ith$ day}}
      \]</p>

      <p> We can then estimate the expected return $r$ for each stock simply as the mean over the time period
      \[ r = \frac{1}{N} D^T \mathbf{1}
      \]
      so that the $ith$ entry of this vector corresponds to the expected return for stock $i$ ($\mathbf{1}$ denotes the vector of ones).</p>

      <p> We use the unbiased estimator for the covariance matrix
      \[
      \Sigma = \frac{1}{N-1}(D - \mathbf{1}r^T ) ^T (D - \mathbf{1}r^T )
      \]</p>
    </div>

    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
        !!! REMOVE NUMPY STUFF !!!
        import numpy as np
        import math
        from gurobipy import *

        !!! CHANGE THIS DATA MATRIX !!!
        # Data Matrix
        D = [[0.02778, 0.00387, 0.00021],
          [0.00387, 0.01112, -0.00020],
          [0.00021, -0.00020, 0.00115]]

        m = Model()

        D = np.array(D)

        n = D.shape[1] # number of stocks
        N = D.shape[0] # number of days traded

        # Mean return for each stock
        e = np.ones(N)
        r = np.dot(D.T,e)/N

        # Covariance matrix
        Dbar = (D - np.outer(e,r))/(math.sqrt(N-1))
        Sigma = np.dot(Dbar.T, Dbar)

        # Add variables for each stock
        x = {};
        for i in range(n):
          x[i] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name = 'x' + str(i))

        m.update()

        # Add constraints
        m.addConstr(quicksum(x[i] for i in range(n)) == 1)

        maxStdDev = 0.05
        variance = 0
        for i in range(n):
          for j in range(n):
              variance += x[i]*Sigma[i][j]*x[j]
        m.addConstr(variance <= maxStdDev*maxStdDev)

        # Set objective
        m.setObjective(quicksum(r[i]*x[i] for i in range(n)), GRB.MAXIMIZE)

        m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>
      <input id="stock_symbol" type="text" value="BA">
      <button onclick="get_quote()">Add Stock</button>
      <div id="demoarea">
      </div>
      <button onclick="compute()">Compute Optimal Portfolio</button>
    </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>



//Width and height
var w = 800;
var h = 500;
var padding = 50;
var len = 20; // include 20 bars

var formatAsPercentage = d3.format(".1%")

var maxRet = [];
for (var i = 0; i < len; i++) {
  maxRet.push(Math.random())
}

var xScale = d3.scale.ordinal()
                      .domain(d3.range(len))
                      .rangeRoundBands([padding, w], 0.05);

var yScale = d3.scale.linear()
                      .domain([0, d3.max(maxRet)])
                      .range([padding, h - padding]);

var yAxisScale = d3.scale.linear().domain([0, d3.max(maxRet)])
                                .range([h - padding, padding]);

//Create SVG element
var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", w)
              .attr("height", h);

//Create bars
svg.selectAll("rect")
.data(maxRet)
.enter()
.append("rect")
.attr("x", function(d, i) {
      return xScale(i);
})
.attr("y", function(d) {
      return h - yScale(d);
})
.attr("width", xScale.rangeBand())
.attr("height", function(d) {
      return yScale(d) - padding;
})
.attr("fill", function(d) {
      return "rgb(0, 0, " + (200) + ")";
});

//Create labels
svg.selectAll("text")
.data(maxRet)
.enter()
.append("text")
.text(function(d) {
      return formatAsPercentage(d);
})
.attr("text-anchor", "middle")
.attr("x", function(d, i) {
      return xScale(i) + xScale.rangeBand() / 2;
})
.attr("y", function(d) {
      return h - yScale(d) + 14;
})
.attr("font-family", "sans-serif")
.attr("font-size", "11px")
.attr("fill", "white");

//Define X axis
var xAxis = d3.svg.axis()
              .scale(xScale)
              .orient("bottom")
              .ticks(5);

//Define Y axis
var yAxis = d3.svg.axis()
              .scale(yAxisScale)
              .orient("left")
              .ticks(5);

//Create X axis
svg.append("g")
    .attr("class", "axis")
    .attr("transform", "translate(0," + (h - padding) + ")")
    .call(xAxis);

svg.append("text")
    .attr("transform", "translate(" + (w / 2) + " ," + (h - padding/4) + ")")
    .style("text-anchor", "middle")
    .attr("font-size", "18px")
    .attr("font-family", "sans-serif")
    .text("Risk");

//Create Y axis
svg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + padding + ",0)")
        .call(yAxis);

svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 )
        .attr("x",0 - (h / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .attr("font-size", "18px")
        .attr("font-family", "sans-serif")
        .text("Return");

var stock_data = {};


function compute() {
  // Need to use Finance API to create a matrix where each column has the evolution of
  // the clsoing price of a stock over several days
  var dataMatrix = [];
  var stock_symbols = Object.keys(stock_data);
  for (var i = 0; i < stock_data[stock_symbols[0]].length; i++) {
    var day_prices = [];
    for (var j = 0; j < stock_symbols.length; j++) {
       day_prices.push(stock_data[stock_symbols[j]][i]);
    }
    dataMatrix.push(day_prices);
  }

  console.log('dataMatrix', dataMatrix);

  d3.json('/resource')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'dataMatrix': dataMatrix}), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);
   if (!error) {
      if ('maxRet' in data) {
        var maxRet = data.maxRet;
        console.log('maxRet', maxRet);

        //Update all rects
        svg.selectAll("rect")
           .data(maxRet)
           .transition()
           .delay(function(d, i) {
                   return i / len * 1000;
           })
           .duration(500)
           .attr("y", function(d) {
                        return h - yScale(d);
           })
           .attr("height", function(d) {
                        return yScale(d) - padding;
           })
           .attr("fill", function(d) {
                        return "rgb(0, 0, " + ((4*d-1.2) * 256) + ")";
           });

        //Update all labels
        svg.selectAll("text")
           .data(maxRet)
           .transition()
           .delay(function(d, i) {
                   return i / len * 1000;
           })
           .duration(500)
           .text(function(d) {
                        return formatAsPercentage(d);
           })
           .attr("x", function(d, i) {
                        return xScale(i) + xScale.rangeBand() / 2;
           })
           .attr("y", function(d) {
                        return h - yScale(d) + 14;
           });

      }
   }
}


var parseDate = d3.time.format("%Y-%m-%d").parse;

var stock_margin = {top: 20, right: 20, bottom: 30, left: 50},
    stock_width = 960 - stock_margin.left - stock_margin.right,
    stock_height = 200 - stock_margin.top - stock_margin.bottom;

var x = d3.time.scale()
    .range([0, stock_width]);

var y = d3.scale.linear()
    .range([stock_height, 0]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.close); });

var quote;

function get_quote() {
 var symbol =  $('#stock_symbol').val();
 if (symbol.length == 0) return;

 console.log('Getting data for', symbol);

 $.ajax({
        url: "https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20yahoo.finance.historicaldata%20where%20symbol%20%3D%20%22" + symbol + "%22%20and%20startDate%20%3D%20%222014-09-11%22%20and%20endDate%20%3D%20%222015-06-30%22&format=json&diagnostics=true&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys&callback=quote",
        dataType: "jsonp",
        jsonp: "callback",
        jsonpCallback: "quote"
    });
 quote = function(data) {
   var stock_quotes = data.query.results.quote;
   var cur;
   var data = [];
   var symbol = stock_quotes[0].Symbol;
   var price_data = [];
   for (var i=0; i < stock_quotes.length; i++) {
      cur = stock_quotes[i];
      data[i] = { date: parseDate(cur.Date), close: +cur.Close}
      price_data[i] = +cur.Close;
   }
  stock_data[symbol] = price_data;
  console.log('Got ', data.length, 'closing prices');

  x.domain(d3.extent(data, function(d) { return d.date; }));
  y.domain(d3.extent(data, function(d) { return d.close; }));

  var stock_svg = d3.select("#demoarea").append("svg")
    .attr("width", stock_width + stock_margin.left + stock_margin.right)
    .attr("height", stock_height + stock_margin.top + stock_margin.bottom)
  .append("g")
    .attr("transform", "translate(" + stock_margin.left + "," + stock_margin.top + ")");

  stock_svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + stock_height + ")")
      .call(xAxis);

  stock_svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Price ($) for " + symbol);

  stock_svg.append("path")
      .datum(data)
      .attr("class", "line")
      .attr("d", line);

 };
}

</script>
