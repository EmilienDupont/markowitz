<!DOCTYPE html>
<meta charset="utf-8">
<!-- Next lines for math/latex -->
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>

<!-- Next lines for styling (CSS) -->

<style>
.axis path,
.axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
}

.axis text {
        font-family: sans-serif;
        font-size: 11px;
}

</style>
<!-- Next lines html -->
<body>
  <!-- Navigation -->
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#datamatrix">Estimating Risk and Return</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <!--Set title and write stuff-->
  <div id="container">
    <div class="section" id="intro">
      <h1>Markowitz Portfolio Optimization</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here
      
      <p>
      We consider the classical portfolio problem introduced by Markowitz in 1952.
      For a set of stocks held over a peridod of time, we wish to maximise the expected return while minimising
      the risk.
      </p>
      
      <p>
      Also add section about Efficient Frontier
      </p>
      
      <p>
      Talk about Finance API and how model can be tested using real data
      </p>
    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>Model description goes here.</p>

<!-- We use tex with $ as usual-->
      <p> 
      We consider $n$ stocks held over a period of time (Add reference to Boyd). We denote by $x_i$ the fraction
      of the total wealth invested in stock $i$, i.e. $\sum_{i=1}^{n} x_i = 1$. In this way, a long position corresponds
      to $x_i > 0$ and a short position to $x_i < 0$. If we assume we cannot go short by a larger amount than $s_i$, we have the constraint
      \[
        x_i \geq s_i
      \]
      for each stock $i$.
      </p>
      
      <p>
      We denote by $r_i$ expected return of stock $i$ over the time period. The total return of the portfolio is then given by
      \[
        \text{return} = r^T x
      \]
      Since we have normalised the $x$ variables, this corresponds to a fractional return. For example, if $\text{return} = 0.12$
      this corresponds to 12% increase in the total value of the portfolio.
      </p>
      
      <p> To estimate the risk we use the variance, which is defined as
      \[
        \text{variance} = x^T \Sigma x
      \]
      where $\Sigma$ is the covariance matrix of the return. We wish to bound the risk, so we can introduce a parameter $\sigma_{max}$
      which will correspond to the maximum standard deviation (risk) allowed. This imposes a constraint
      \[
        x^T \Sigma x \leq \sigma_{max}^2
      \]
      </p>
      
      <p> So finally our model becomes
       \[
      \begin{array}{ll}
      \text{maximize} & r^t x \\
      \text{subject to} & \sum_{i=1}^{n} x_i = 1 \\
                        & x_i \geq 0 \quad \text{for} \, i=1,..,n \\
                        & x^T \Sigma x \leq \sigma_{max}^2
      \end{array}
      \]
      By solving the optimization problem for various values of the parameter $\sigma_{max}$ we can compute the efficient frontier for the problem.
      </p>
      
      </div>
      <div class="section" id="datamatrix">
      <h2><a href="#datamatrix" name="datamatrix">Estimating Risk and Return</a></h2>
      <p>
      There are several ways of computing the expected return and the variance. For this implementation, we use data collected from Yahoo Finance API
      giving the closing price of various stocks for the past $N$ days. We can then use this data to estimate the return and variance.
      </p>
      
      <p>
      For $n$ stocks and $N$ daily closing prices we define an $N \times n$ data matrix $D$, so that each
      column holds all the information for a single stock. So for each stock $j$ we define
       \[
      D_{ij} = \frac{ \text{closing price of $jth$ stock on $(i+1)th$ day}}{ \text{closing price of $jth$ stock on $ith$ day}}
      \]</p>
      
      <p> We can then estimate the expected return $r$ for each stock simply as the mean over the time period
      \[ r = \frac{1}{N} D^T \mathbf{1}
      \]
      so that the $ith$ entry of this vector corresponds to the expected return for stock $i$.</p>
      
      <p> We use the unbiased estimator for the covariance matrix
      \[
      \Sigma = \frac{1}{N-1}(D - \mathbf{1}r^T ) ^T (D - \mathbf{1}r^T )
      \]</p>
    </div>
      
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
        DOUBLE CHECK THIS
        import numpy as np
        import math
        from gurobipy import *

        !!! CHANGE THIS DATA MATRIX !!!
        # Data Matrix
        D = [[0.02778, 0.00387, 0.00021],
          [0.00387, 0.01112, -0.00020],
          [0.00021, -0.00020, 0.00115]]
        
        m = Model()
        
        D = np.array(D)
        
        n = D.shape[1] # number of stocks
        N = D.shape[0] # number of days traded
        
        # Mean return for each stock
        e = np.ones(N)
        r = np.dot(D.T,e)/N
        
        # Covariance matrix
        Dbar = (D - np.outer(e,r))/(math.sqrt(N-1))
        Sigma = np.dot(Dbar.T, Dbar)
        
        # Add variables for each stock
        x = {};
        for i in range(n):
          x[i] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name = 'x' + str(i))
        
        m.update()
        
        # Add constraints
        m.addConstr(quicksum(x[i] for i in range(n)) == 1)
        
        maxStdDev = 0.05
        variance = 0
        for i in range(n):
          for j in range(n):
              variance += x[i]*Sigma[i][j]*x[j]
        m.addConstr(variance <= maxStdDev*maxStdDev)
        
        # Set objective
        m.setObjective(quicksum(r[i]*x[i] for i in range(n)), GRB.MAXIMIZE)
        
        m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>
      <!-- Where we put graphics -->
      <div id="demoarea">
      </div>
      <!-- When button is clicked => calls compute() -->
      <button onclick="compute()">Compute Optimal Portfolio</button>
    </div>

    <!-- Load d3 library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<!-- After script, javascript -->
<script>



//Width and height
var w = 800;
var h = 500;
var padding = 50;
var len = 20; // include 20 bars

var formatAsPercentage = d3.format(".1%")

var maxRet = [];
for (var i = 0; i < len; i++) {
  maxRet.push(Math.random())
}

var xScale = d3.scale.ordinal()
                      .domain(d3.range(len))
                      .rangeRoundBands([padding, w], 0.05);

var yScale = d3.scale.linear()
                      .domain([0, d3.max(maxRet)])
                      .range([padding, h - padding]);

var yAxisScale = d3.scale.linear().domain([0, d3.max(maxRet)])
                                .range([h - padding, padding]);

//Create SVG element
var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", w)
              .attr("height", h);



//Create bars
svg.selectAll("rect")
.data(maxRet)
.enter()
.append("rect")
.attr("x", function(d, i) {
      return xScale(i);
})
.attr("y", function(d) {
      return h - yScale(d);
})
.attr("width", xScale.rangeBand())
.attr("height", function(d) {
      return yScale(d) - padding;
})
.attr("fill", function(d) {
      return "rgb(0, 0, " + (200) + ")";
});

//Create labels
svg.selectAll("text")
.data(maxRet)
.enter()
.append("text")
.text(function(d) {
      return formatAsPercentage(d);
})
.attr("text-anchor", "middle")
.attr("x", function(d, i) {
      return xScale(i) + xScale.rangeBand() / 2;
})
.attr("y", function(d) {
      return h - yScale(d) + 14;
})
.attr("font-family", "sans-serif")
.attr("font-size", "11px")
.attr("fill", "white");

//Define X axis
var xAxis = d3.svg.axis()
              .scale(xScale)
              .orient("bottom")
              .ticks(5);

//Define Y axis
var yAxis = d3.svg.axis()
              .scale(yAxisScale)
              .orient("left")
              .ticks(5);

//Create X axis
svg.append("g")
    .attr("class", "axis")
    .attr("transform", "translate(0," + (h - padding) + ")")
    .call(xAxis);

svg.append("text")
    .attr("transform", "translate(" + (w / 2) + " ," + (h - padding/4) + ")")
    .style("text-anchor", "middle")
    .attr("font-size", "18px")
    .attr("font-family", "sans-serif")
    .text("Risk");

//Create Y axis
svg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + padding + ",0)")
        .call(yAxis);

svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 )
        .attr("x",0 - (h / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .attr("font-size", "18px")
        .attr("font-family", "sans-serif")
        .text("Return");

function compute() {
  dataMatrix = [];
  for (var i = 0; i < 5; i++) {
    row = [];
    for (var j = 0; j < 5; j++) {
      row.push(Math.random())
    }
    dataMatrix.push(row)
  }
  
  console.log('dataMatrix', dataMatrix); // write out to the log (like print)

  d3.json('/resource') // using json (javascript format) function to send stuff to /resource page
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'dataMatrix': dataMatrix}), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data); // Print out data
   if (!error) { // error = 0 => everything okay
      if ('maxRet' in data) { // data is dict, should have a key cover
        var maxRet = data.maxRet;
        console.log('maxRet', maxRet);
        
        //Update all rects
        svg.selectAll("rect")
           .data(maxRet)
           .transition()
           .delay(function(d, i) {
                   return i / len * 1000;
           })
           .duration(500)
           .attr("y", function(d) {
                        return h - yScale(d);
           })
           .attr("height", function(d) {
                        return yScale(d) - padding;
           })
           .attr("fill", function(d) {
                        return "rgb(0, 0, " + ((4*d-1.2) * 256) + ")";
           });
  
        //Update all labels
        svg.selectAll("text")
           .data(maxRet)
           .transition()
           .delay(function(d, i) {
                   return i / len * 1000;
           })
           .duration(500)
           .text(function(d) {
                        return formatAsPercentage(d);
           })
           .attr("x", function(d, i) {
                        return xScale(i) + xScale.rangeBand() / 2;
           })
           .attr("y", function(d) {
                        return h - yScale(d) + 14;
           });
        
      }
   }
}

</script>